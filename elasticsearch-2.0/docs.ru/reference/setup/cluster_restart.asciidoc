[[restart-upgrade]]
=== Обновление с полным перезапуском кластера

Elasticsearch требует полного перезапуска кластера, когда происходит
обновление между мажорными версиями: с 0.x до 1.x или с 1.x на 2.x.
Для обновлений между мажорными версиями накатывающие обновления не
поддерживаются.

Процесс выполнения обновления с полным рестартом кластера следующий:

==== Шаг 1: Выключите размещение шардов

Когда вы погасите узел, процесс размещения шардов будет немедленно
пытаться реплицировать шарды, которые были на погашенном узле на
другие узлы этого же кластера, что вызовет большую нагрузку на
подсистему ввода/вывода. Этого можно избежать, выключив размещение
шардов перед завершением работы узла:

[source,js]
--------------------------------------------------
PUT /_cluster/settings
{
  "persistent": {
    "cluster.routing.allocation.enable": "none"
  }
}
--------------------------------------------------
// AUTOSENSE

Если вы обновляетесь с 0.90.x на 1.x, то используйте вместо этого
данные настройки:

[source,js]
--------------------------------------------------
PUT /_cluster/settings
{
  "persistent": {
    "cluster.routing.allocation.disable_allocation": false,
    "cluster.routing.allocation.enable": "none"
  }
}
--------------------------------------------------
// AUTOSENSE

==== Шаг 2: Выполните синхронный сброс буферов на диск

Восстановление шардов будет происходить намного быстрее, если вы
остановите индексирование и выполните запрос
<<indices-synced-flush, синхровнного сброса буферов на диск>>:

[source,sh]
--------------------------------------------------
POST /_flush/synced
--------------------------------------------------
// AUTOSENSE

Запрос на синхронный сброс буферов является операцией ``наибольших усилий''.
Она завершится неудачно, если будут выполняться любые операции индексирования,
но её можно безопасно выполнять любое количество раз, которое необходимо.

==== Шаг 3: Выключение и обновление всех узлов

Остановите все службы Elasticsearch на всех узлах кластера. Каждый узел может
быть обновлён по процедуре описанной в <<upgrade-node>>.

==== Step 4: Запуск кластера

Если у вас есть отдельные master узлы - узлы, у которы настройка `node.master`
установлена в `true` (по умолчанию) и `node.data` в `false` -- то лучше
запустить их первыми. Ждите пока они сформируют кластер и выберут master'а
перед тем как включать узлы данных. Вы можете отслеживать ход этого процесса
в логах.

Как только <<master-election,минимальное количество приемлимых для выбора master'а узлов>>
увидит друг друга, они сформируют кластер и выберут master узел. С этого
момента можно мониторить как узлы подключаются к кластеру с помощью API
<<cat-health,`_cat/health`>> and <<cat-nodes,`_cat/nodes`>>.

[source,sh]
--------------------------------------------------
GET _cat/health

GET _cat/nodes
--------------------------------------------------
// AUTOSENSE

Истользуйте эти API запросы для отслеживания, что все узлы успешно подключились
к кластеру.

==== Шаг 5: Ждите состояния yellow

Как только каждый узел присоединится к кластеру, на нём запустится восстановление
всех первичных шардов, которые хранятся локально. Запрсы
<<cat-health,`_cat/health`>> покажут у `status` значение `red`, говорящее,
что не все первичные шарды были размещены.

Как только каждый узел восстановит свои локальные шарды, значение `status`
изменится на `yellow`, говорящее, что все первичные шарды были восстановлены,
но не все реплики шардов были размещены. Это вполне ожидаемо, потому что
их размещение было выключено.

==== Шаг 6: Включите размещение реплик шардов

Мы ждём когда все присоединённые к кластеру узлы позволят master'у размещать
реплики на узлах, которые уже имеют копии локальных шардов. С этого момента,
когда все узлы уже в кластере, можно безопасно разрешить размещение реплик
шардов:

[source,js]
------------------------------------------------------
PUT /_cluster/settings
{
  "persistent": {
    "cluster.routing.allocation.enable": "all"
  }
}
------------------------------------------------------
// AUTOSENSE

Если вы обновляетесь с 0.90.x до 1.x, то используйте вместо этого
настройку:

[source,js]
--------------------------------------------------
PUT /_cluster/settings
{
  "persistent": {
    "cluster.routing.allocation.disable_allocation": true,
    "cluster.routing.allocation.enable": "all"
  }
}
--------------------------------------------------
// AUTOSENSE

Теперь кластер запущен со всеми репликами шардов на всех узлах с данными.
С этого момента, можно продолжить индексацию и поиск, но ваш кластер
будет восстанавливаться быстрее, если вы отложите индексирование и
поиск пока все шарды не восстановятся.

Вы можете мониторить этот процесс с помощью API запросов:
<<cat-health,`_cat/health`>> и <<cat-recovery,`_cat/recovery`>>:

[source,sh]
--------------------------------------------------
GET _cat/health

GET _cat/recovery
--------------------------------------------------
// AUTOSENSE

Как только значение поля `status` в выводе `_cat/health` станет `green`,
это будет означать, что все первичные шарды и их реплики успешно
размещены на всех узлах кластера.
